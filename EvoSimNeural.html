<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Odyssey</title>
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            width: 100%; 
            height: 100%; 
            background-color: #000; 
            user-select: none; 
        }
        canvas { 
            display: block; 
            border: none; 
        }
        .counter { 
            position: absolute; 
            top: 1vh; 
            color: white; 
            font-family: Arial, sans-serif; 
            font-size: 1.5vh; 
            user-select: none; 
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #creatureCounter {
            right: 1vh;
        }
        #foodCounter {
            right: 1vh;
            top: 3vh;
        }
        #creatureStats {
            left: 1vh;
            top: 1vh;
            white-space: pre-wrap;
            font-size: 1.2vh;
        }
        #optionsMenu {
            position: absolute;
            bottom: 2vh;
            right: 2vh;
            width: calc(100vw - 4vh);
            max-width: 600px;
            background-color: rgba(0, 0, 0, 0.9);
            border: 1px solid #fff;
            border-radius: 10px;
            padding: 1vh;
            display: none;
            flex-direction: column;
            gap: 0.5vh;
            z-index: 1000;
        }
        .option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif; 
            font-size: 1.2vh;
            margin-bottom: 0.5vh;
        }
        .option label {
            flex: 1;
            text-align: left;
        }
        .option input[type="range"],
        .option input[type="number"] {
            margin-left: 0.5vh;
            margin-right: 0.5vh;
            border-radius: 5px;
        }
        .option input[type="number"] {
            width: 6vh;
            background: transparent;
            border: 1px solid #fff;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 1.2vh;
            text-align: center;
        }
        .slider-label {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 1.2vh;
            user-select: none;
        }
        .slider {
            flex: 1;
        }
        #gearIcon {
            position: absolute;
            bottom: 1vh;
            right: 1vh;
            cursor: pointer;
            font-size: 3vh;
            color: white;
            z-index: 1000;
        }
        .tabs {
            display: flex;
            cursor: pointer;
            margin-bottom: 0.5vh;
        }
        .tab {
            flex: 1;
            padding: 0.5vh;
            text-align: center;
            background: #333;
            color: white;
            border: 1px solid #fff;
            border-radius: 5px;
            font-size: 1.2vh;
        }
        .tab.active {
            background: #555;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .save-slot {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5vh;
        }
        .save-slot input {
            width: 60%;
            background: transparent;
            border: 1px solid #fff;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 1.2vh;
            text-align: center;
            border-radius: 5px;
        }
        .save-slot button,
        .reset-button,
        #pauseButton {
            width: 35%;
            background: #444;
            border: 1px solid #fff;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 1.2vh;
            cursor: pointer;
            border-radius: 5px;
        }
        @media screen and (max-height: 400px) {
            #optionsMenu {
                bottom: 1vh;
                right: 1vh;
                width: calc(100vw - 2vh);
                max-width: none;
                padding: 0.5vh;
            }
            .option, .save-slot, .reset-button {
                flex-direction: column;
                align-items: flex-start;
            }
            .option input[type="number"], .save-slot input {
                width: 100%;
                margin-top: 0.5vh;
            }
            .save-slot button, #pauseButton {
                width: 100%;
                margin-top: 0.5vh;
            }
            .reset-button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <canvas id="simCanvas"></canvas>
    <div id="creatureCounter" class="counter"></div>
    <div id="foodCounter" class="counter"></div>
    <div id="creatureStats" class="counter"></div>
    <div id="gearIcon">âš™</div>
    <div id="optionsMenu">
        <div class="tabs">
            <div class="tab active" data-tab="settings">Settings</div>
            <div class="tab" data-tab="save">Save/Load</div>
            <div class="tab" data-tab="reset">Reset</div>
        </div>
        <div id="settings" class="tab-content active">
            <div class="option">
                <label for="creatureSizeSlider" class="slider-label">Creature Size</label>
                <input type="range" id="creatureSizeSlider" class="slider" min="0" max="10" step="0.1" value="0.7">
                <input type="number" id="creatureSizeNumber" min="0" max="10" step="0.1" value="0.7">
            </div>
            <div class="option">
                <label for="foodSizeSlider" class="slider-label">Food Size</label>
                <input type="range" id="foodSizeSlider" class="slider" min="0" max="10" step="0.1" value="0.5">
                <input type="number" id="foodSizeNumber" min="0" max="10" step="0.1" value="0.5">
            </div>
            <div class="option">
                <label for="maxFoodItems" class="slider-label">Max Food Items</label>
                <input type="range" id="maxFoodItems" min="0" max="2000" step="10" value="1500">
                <input type="number" id="maxFoodItemsNumber" min="0" max="2000" step="10" value="1500">
            </div>
            <div class="option">
                <label for="minFoodItems" class="slider-label">Min Food Items</label>
                <input type="range" id="minFoodItems" min="0" max="1500" step="10" value="200">
                <input type="number" id="minFoodItemsNumber" min="0" max="1500" step="10" value="200">
            </div>
            <div class="option">
                <label for="maxCreatures" class="slider-label">Max Creatures</label>
                <input type="range" id="maxCreatures" min="0" max="1000" step="10" value="500">
                <input type="number" id="maxCreaturesNumber" min="0" max="1000" step="10" value="500">
            </div>
            <div class="option">
                <label for="minCreatures" class="slider-label">Min Creatures</label>
                <input type="range" id="minCreatures" min="0" max="1000" step="10" value="150">
                <input type="number" id="minCreaturesNumber" min="0" max="1000" step="10" value="150">
            </div>
            <div class="option">
                <label for="foodEnergy" class="slider-label">Food Energy</label>
                <input type="range" id="foodEnergy" min="0" max="500" step="1" value="25">
                <input type="number" id="foodEnergyNumber" min="0" max="500" step="1" value="25">
            </div>
            <div class="option">
                <label for="foodSpawnInterval" class="slider-label">Food Spawn Interval (ms)</label>
                <input type="range" id="foodSpawnInterval" min="0" max="10000" step="100" value="1000">
                <input type="number" id="foodSpawnIntervalNumber" min="0" max="10000" step="100" value="1000">
            </div>
            <div class="option">
                <label for="visionRangeFactor" class="slider-label">Vision Range Factor</label>
                <input type="range" id="visionRangeFactor" min="0" max="50" step="1" value="10">
                <input type="number" id="visionRangeFactorNumber" min="0" max="50" step="1" value="10">
            </div>
            <div class="option">
                <label for="maxSpeed" class="slider-label">Max Speed</label>
                <input type="range" id="maxSpeed" min="0" max="1000" step="10" value="200">
                <input type="number" id="maxSpeedNumber" min="0" max="1000" step="10" value="200">
            </div>
            <div class="option">
                <label for="maxEnergy" class="slider-label">Max Energy</label>
                <input type="range" id="maxEnergy" min="0" max="10000" step="100" value="2000">
                <input type="number" id="maxEnergyNumber" min="0" max="10000" step="100" value="2000">
            </div>
            <div class="option">
                <label for="baseMutationRate" class="slider-label">Mutation Rate</label>
                <input type="range" id="baseMutationRate" min="0" max="1" step="0.01" value="0.1">
                <input type="number" id="baseMutationRateNumber" min="0" max="1" step="0.01" value="0.1">
            </div>
            <div class="option">
                <label for="colorDifferenceThreshold" class="slider-label">Color Difference Threshold</label>
                <input type="range" id="colorDifferenceThreshold" min="0" max="200" step="1" value="36">
                <input type="number" id="colorDifferenceThresholdNumber" min="0" max="200" step="1" value="36">
            </div>
            <div class="option">
                <label for="foodGrowthRate" class="slider-label">Food Growth Rate</label>
                <input type="range" id="foodGrowthRate" min="0.05" max="10" step="0.001" value="0.75">
                <input type="number" id="foodGrowthRateNumber" min="0.05" max="10" step="0.001" value="0.75">
            </div>
            <div class="option">
                <label for="offspringEnergyFraction" class="slider-label">Offspring Energy Fraction</label>
                <input type="range" id="offspringEnergyFraction" min="0" max="1" step="0.1" value="0.25">
                <input type="number" id="offspringEnergyFractionNumber" min="0" max="1" step="0.1" value="0.25">
            </div>
            <div class="option">
                <label for="absorptionRate" class="slider-label">Absorption Rate</label>
                <input type="range" id="absorptionRate" min="0" max="100" step="1" value="50">
                <input type="number" id="absorptionRateNumber" min="0" max="100" step="1" value="50">
            </div>
            <div class="option">
                <label for="sizeEnergyMultiplier" class="slider-label">Size Energy Multiplier</label>
                <input type="range" id="sizeEnergyMultiplier" min="0" max="10" step="0.1" value="1">
                <input type="number" id="sizeEnergyMultiplierNumber" min="0" max="10" step="0.1" value="1">
            </div>
            <div class="option">
                <label for="speedEnergyMultiplier" class="slider-label">Speed Energy Multiplier</label>
                <input type="range" id="speedEnergyMultiplier" min="0" max="20" step="1" value="5">
                <input type="number" id="speedEnergyMultiplierNumber" min="0" max="20" step="1" value="5">
            </div>
            <div class="option">
                <label for="maxAcceleration" class="slider-label">Max Acceleration</label>
                <input type="range" id="maxAcceleration" min="0" max="100" step="1" value="20">
                <input type="number" id="maxAccelerationNumber" min="0" max="100" step="1" value="20">
            </div>
            <div class="option">
                <label for="desiredAverageSpeed" class="slider-label">Desired Average Speed</label>
                <input type="range" id="desiredAverageSpeed" min="0" max="200" step="1" value="75">
                <input type="number" id="desiredAverageSpeedNumber" min="0" max="200" step="1" value="75">
            </div>
            <div class="option">
                <label for="baseEnergyLossRate" class="slider-label">Base Energy Loss Rate</label>
                <input type="range" id="baseEnergyLossRate" min="0" max="1" step="0.01" value="0.1">
                <input type="number" id="baseEnergyLossRateNumber" min="0" max="1" step="0.01" value="0.1">
            </div>
            <div class="option">
                <label for="targetCreatureCount" class="slider-label">Target Creature Count</label>
                <input type="range" id="targetCreatureCount" min="0" max="1000" step="10" value="250">
                <input type="number" id="targetCreatureCountNumber" min="0" max="1000" step="10" value="250">
            </div>
            <button id="pauseButton">Pause</button>
        </div>
        <div id="save" class="tab-content">
            <div class="save-slot">
                <input type="text" id="saveSlotName1" placeholder="Save Slot 1">
                <button onclick="saveState(1)">Save</button>
                <button onclick="loadState(1)">Load</button>
            </div>
            <div class="save-slot">
                <input type="text" id="saveSlotName2" placeholder="Save Slot 2">
                <button onclick="saveState(2)">Save</button>
                <button onclick="loadState(2)">Load</button>
            </div>
            <div class="save-slot">
                <input type="text" id="saveSlotName3" placeholder="Save Slot 3">
                <button onclick="saveState(3)">Save</button>
                <button onclick="loadState(3)">Load</button>
            </div>
            <div class="save-slot">
                <input type="text" id="saveSlotName4" placeholder="Save Slot 4">
                <button onclick="saveState(4)">Save</button>
                <button onclick="loadState(4)">Load</button>
            </div>
            <div class="save-slot">
                <input type="text" id="saveSlotName5" placeholder="Save Slot 5">
                <button onclick="saveState(5)">Save</button>
                <button onclick="loadState(5)">Load</button>
            </div>
            <div class="save-slot">
                <input type="text" id="saveSlotName6" placeholder="Save Slot 6">
                <button onclick="saveState(6)">Save</button>
                <button onclick="loadState(6)">Load</button>
            </div>
            <div class="save-slot">
                <input type="text" id="saveSlotName7" placeholder="Save Slot 7">
                <button onclick="saveState(7)">Save</button>
                <button onclick="loadState(7)">Load</button>
            </div>
            <div class="save-slot">
                <input type="text" id="saveSlotName8" placeholder="Save Slot 8">
                <button onclick="saveState(8)">Save</button>
                <button onclick="loadState(8)">Load</button>
            </div>
            <div class="save-slot">
                <input type="text" id="saveSlotName9" placeholder="Save Slot 9">
                <button onclick="saveState(9)">Save</button>
                <button onclick="loadState(9)">Load</button>
            </div>
            <div class="save-slot">
                <input type="text" id="saveSlotName10" placeholder="Save Slot 10">
                <button onclick="saveState(10)">Save</button>
                <button onclick="loadState(10)">Load</button>
            </div>
        </div>        
        <div id="reset" class="tab-content">
            <button class="reset-button" onclick="resetSettings()">Reset Settings</button>
            <button class="reset-button" onclick="resetPopulation()">Reset Enities</button>
            <button class="reset-button" onclick="resetSimulation()">Reset All</button>
            <button class="reset-button" onclick="deleteAllSaves()">Delete All Saves</button>
        </div>      
    </div>   
    <script>
        const defaultConfig = {
            maxFoodItems: 1500,
            minFoodItems: 200,
            maxCreatures: 500,
            minCreatures: 150,
            foodEnergy: 25,
            maxFoodSize: 60,
            minFoodSize: 0.2,
            foodSpawnInterval: 1000,
            visionRangeFactor: 30,
            maxSpeed: 200,
            maxEnergy: 2000,
            baseMutationRate: 0.1,
            colorDifferenceThreshold: 36,
            foodGrowthRate: 0.75,
            offspringEnergyFraction: 0.25,
            absorptionRate: 10,
            sizeEnergyMultiplier: 1,
            speedEnergyMultiplier: 5,
            maxAcceleration: 20,
            desiredAverageSpeed: 50,
            baseEnergyLossRate: 0.1,
            initialCreatures: 300,
            initialFoodItems: 1000,
            targetCreatureCount: 250,
            adjustmentRate: 0.0001,
            overlayFadeDelay: 10000,
            maxNearbyFood: 10,
            maxNearbyCreatures: 5
        };

        const defaultCreatureSize = 0.7;
        const defaultFoodSize = 0.5;

        let CONFIG = { ...defaultConfig };

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        const creatureCounter = document.getElementById('creatureCounter');
        const foodCounter = document.getElementById('foodCounter');
        const creatureStats = document.getElementById('creatureStats');
        const creatureSizeSlider = document.getElementById('creatureSizeSlider');
        const creatureSizeNumber = document.getElementById('creatureSizeNumber');
        const foodSizeSlider = document.getElementById('foodSizeSlider');
        const foodSizeNumber = document.getElementById('foodSizeNumber');
        const optionsMenu = document.getElementById('optionsMenu');
        const gearIcon = document.getElementById('gearIcon');
        const pauseButton = document.getElementById('pauseButton');

        const options = [
            { slider: 'maxFoodItems', number: 'maxFoodItemsNumber' },
            { slider: 'minFoodItems', number: 'minFoodItemsNumber' },
            { slider: 'maxCreatures', number: 'maxCreaturesNumber' },
            { slider: 'minCreatures', number: 'minCreaturesNumber' },
            { slider: 'foodEnergy', number: 'foodEnergyNumber' },
            { slider: 'foodSpawnInterval', number: 'foodSpawnIntervalNumber' },
            { slider: 'visionRangeFactor', number: 'visionRangeFactorNumber' },
            { slider: 'maxSpeed', number: 'maxSpeedNumber' },
            { slider: 'maxEnergy', number: 'maxEnergyNumber' },
            { slider: 'baseMutationRate', number: 'baseMutationRateNumber' },
            { slider: 'colorDifferenceThreshold', number: 'colorDifferenceThresholdNumber' },
            { slider: 'foodGrowthRate', number: 'foodGrowthRateNumber' },
            { slider: 'offspringEnergyFraction', number: 'offspringEnergyFractionNumber' },
            { slider: 'absorptionRate', number: 'absorptionRateNumber' },
            { slider: 'sizeEnergyMultiplier', number: 'sizeEnergyMultiplierNumber' },
            { slider: 'speedEnergyMultiplier', number: 'speedEnergyMultiplierNumber' },
            { slider: 'maxAcceleration', number: 'maxAccelerationNumber' },
            { slider: 'desiredAverageSpeed', number: 'desiredAverageSpeedNumber' },
            { slider: 'baseEnergyLossRate', number: 'baseEnergyLossRateNumber' },
            { slider: 'targetCreatureCount', number: 'targetCreatureCountNumber' }
        ];

        let creatures = [];
        let foodItems = [];
        let lastFoodSpawnTime = 0;
        let currentSpawn = null;
        let kingCreature = null;
        let lastClickedCreature = null;
        let lastClickTime = 0;
        let isPaused = false;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            creatures.forEach(creature => creature.wrapAroundCanvas());
            foodItems.forEach(food => food.wrapAroundCanvas());
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function randomColor() {
            return `hsl(${Math.floor(Math.random() * 360)}, 100%, 50%)`;
        }

        function getColorHue(color) {
            return parseInt(color.match(/\d+/)[0]);
        }

        function colorDifference(color1, color2) {
            const hue1 = getColorHue(color1);
            const hue2 = getColorHue(color2);
            return Math.min(Math.abs(hue1 - hue2), 360 - Math.abs(hue1 - hue2));
        }

        function mutateColor(color) {
            const hue = getColorHue(color);
            const newHue = (hue + Math.floor(Math.random() * 72) - 36 + 360) % 360;
            return `hsl(${newHue}, 100%, 50%)`;
        }

        function mutateValue(value, rate) {
            return value + (Math.random() * 2 - 1) * rate * value;
        }

        function updateCounters() {
            creatureCounter.textContent = `Creatures: ${creatures.length}`;
            foodCounter.textContent = `Food: ${foodItems.length}`;
        }

        function updateCreatureStats() {
            if (lastClickedCreature && lastClickedCreature.alive) {
                const energyLossRate = lastClickedCreature.baseEnergyLossRate * lastClickedCreature.size;
                creatureStats.textContent = `Creature Stats:\nSize: ${lastClickedCreature.size.toFixed(2)}\nEnergy: ${lastClickedCreature.energy.toFixed(2)}\nMax Energy: ${lastClickedCreature.maxEnergy.toFixed(2)}\nSpeed: ${lastClickedCreature.speed.toFixed(2)}\nAcceleration: ${lastClickedCreature.acceleration.toFixed(2)}\nEnergy Loss Rate: ${energyLossRate.toFixed(5)}\nColor: ${lastClickedCreature.color}`;
            } else {
                creatureStats.textContent = '';
            }
        }

        class NeuralNetwork {
            constructor(layerSizes) {
                this.weights = [];
                this.biases = [];
                for (let i = 0; i < layerSizes.length - 1; i++) {
                    this.weights.push(this.randomMatrix(layerSizes[i], layerSizes[i + 1]));
                    this.biases.push(this.randomMatrix(1, layerSizes[i + 1]));
                }
            }

            randomMatrix(rows, cols) {
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    const row = [];
                    for (let j = 0; j < cols; j++) {
                        row.push(Math.random() * 2 - 1);
                    }
                    matrix.push(row);
                }
                return matrix;
            }

            mutate(rate) {
                this.weights = this.weights.map(matrix => this.mutateMatrix(matrix, rate));
                this.biases = this.biases.map(matrix => this.mutateMatrix(matrix, rate));
            }

            mutateMatrix(matrix, rate) {
                return matrix.map(row => row.map(value => value + (Math.random() * 2 - 1) * rate));
            }

            feedforward(inputs) {
                let activations = inputs;
                for (let i = 0; i < this.weights.length; i++) {
                    activations = this.sigmoid(this.addMatrix(this.dot(activations, this.weights[i]), this.biases[i]));
                }
                return activations;
            }

            dot(a, b) {
                const result = [];
                for (let i = 0; i < a.length; i++) {
                    const row = [];
                    for (let j = 0; j < b[0].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < a[0].length; k++) {
                            sum += a[i][k] * b[k][j];
                        }
                        row.push(sum);
                    }
                    result.push(row);
                }
                return result;
            }

            addMatrix(a, b) {
                return a.map((row, i) => row.map((val, j) => val + b[i][j]));
            }

            sigmoid(matrix) {
                return matrix.map(row => row.map(val => 1 / (1 + Math.exp(-val))));
            }
        }

        class Food {
            constructor(x, y, energy) {
                this.x = x;
                this.y = y;
                this.energy = energy;
                this.size = Math.sqrt(energy) * parseFloat(foodSizeSlider.value);
                this.dragging = false;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            handleInteractionStart(x, y) {
                if (Math.hypot(x - this.x, y - this.y) < this.size) {
                    this.dragging = true;
                    this.dragStartX = x - this.x;
                    this.dragStartY = y - this.y;
                }
            }

            handleInteractionMove(x, y) {
                if (this.dragging) {
                    this.x = x - this.dragStartX;
                    this.y = y - this.dragStartY;
                    this.wrapAroundCanvas();
                }
            }

            handleInteractionEnd() {
                this.dragging = false;
            }

            handleDoubleClick(x, y) {
                if (Math.hypot(x - this.x, y - this.y) < this.size) {
                    spawnCreature(this.x, this.y);
                    return true;
                }
                return false;
            }

            grow() {
                if (this.size < CONFIG.maxFoodSize) {
                    this.energy += CONFIG.foodGrowthRate;
                    this.size = Math.sqrt(this.energy) * parseFloat(foodSizeSlider.value);
                }
            }

            wrapAroundCanvas() {
                this.x = (this.x % canvas.width + canvas.width) % canvas.width;
                this.y = (this.y % canvas.height + canvas.height) % canvas.height;
            }

            isOutOfBounds() {
                return (
                    this.x < 0 || this.x >= canvas.width ||
                    this.y < 0 || this.y >= canvas.height
                );
            }
        }

        class Creature {
            constructor(x, y, traits = {}, parent = null) {
                this.x = x;
                this.y = y;
                this.maxEnergy = traits.maxEnergy || Math.random() * CONFIG.maxEnergy;
                this.reproductionThreshold = this.maxEnergy * 0.9;
                this.energy = traits.energy || this.reproductionThreshold / 2;
                this.size = Math.sqrt(this.energy) * CONFIG.sizeEnergyMultiplier * parseFloat(creatureSizeSlider.value);
                this.color = traits.color || randomColor();
                this.direction = Math.random() * 2 * Math.PI;
                this.alive = true;
                this.dragging = false;
                this.lastClickTime = 0;
                this.parent = parent;

                this.speed = 0;
                this.maxSpeed = traits.maxSpeed || CONFIG.maxSpeed * CONFIG.speedEnergyMultiplier / this.size;
                this.acceleration = 0;
                this.maxAcceleration = traits.maxAcceleration || CONFIG.maxAcceleration;
                this.deceleration = this.maxAcceleration / 2;
                this.baseEnergyLossRate = traits.baseEnergyLossRate || CONFIG.baseEnergyLossRate;

                this.visionRange = this.calculateVisionRange();

                this.brain = traits.brain ? new NeuralNetwork(traits.brain.layerSizes) : new NeuralNetwork([9, 16, 3]);
                if (traits.brain) {
                    this.brain.weights = traits.brain.weights;
                    this.brain.biases = traits.brain.biases;
                }
            }

            calculateVisionRange() {
                return this.size * CONFIG.visionRangeFactor;
            }

            move(deltaTime) {
                if (this.energy <= 0 || this.maxEnergy <= 0) {
                    this.alive = false;
                    return;
                }

                if (!this.dragging && !isPaused) {
                    const speedScale = canvas.width / 1920;

                    const previousX = this.x;
                    const previousY = this.y;
                    const previousDirection = this.direction;
                    this.seekFoodOrAvoidDanger();
                    const angleChange = Math.abs(this.direction - previousDirection);

                    const turnFactor = Math.max(0.1, 1 - angleChange / Math.PI);

                    let targetSpeed = this.maxSpeed * turnFactor;
                    
                    if (this.seekingFood) {
                        targetSpeed = Math.min(this.maxSpeed, this.speed + this.acceleration * deltaTime);
                    } else {
                        targetSpeed = Math.max(0, this.speed - this.deceleration * deltaTime);
                    }

                    this.speed = Math.max(0, Math.min(this.maxSpeed, targetSpeed));

                    const moveStep = this.speed * deltaTime * speedScale;
                    this.x += Math.cos(this.direction) * moveStep;
                    this.y += Math.sin(this.direction) * moveStep;

                    const distanceTraveled = Math.hypot(this.x - previousX, this.y - previousY);
                    const energyLossRate = this.baseEnergyLossRate * this.size;
                    this.energy -= distanceTraveled * energyLossRate;

                    this.wrapAroundCanvas();
                    this.size = Math.sqrt(this.energy) * CONFIG.sizeEnergyMultiplier * parseFloat(creatureSizeSlider.value);
                    
                    this.preventOverlap();
                }
            }

            wrapAroundCanvas() {
                this.x = (this.x % canvas.width + canvas.width) % canvas.width;
                this.y = (this.y % canvas.height + canvas.height) % canvas.height;
            }

            seekFoodOrAvoidDanger() {
                this.visionRange = this.calculateVisionRange();
                const numCols = 20;
                const cellSize = canvas.width / numCols;
                const numRows = Math.ceil(canvas.height / cellSize);
                const col = Math.floor(this.x / cellSize);
                const row = Math.floor(this.y / cellSize);
                
                const cellsToCheck = [];
                for (let dRow = -1; dRow <= 1; dRow++) {
                    for (let dCol = -1; dCol <= 1; dCol++) {
                        const neighborRow = (row + dRow + numRows) % numRows;
                        const neighborCol = (col + dCol + numCols) % numCols;
                        cellsToCheck.push(grid[neighborRow][neighborCol]);
                    }
                }

                let nearbyFood = [];
                let nearbyCreatures = [];
                cellsToCheck.forEach(cell => {
                    nearbyFood.push(...cell.foodItems);
                    nearbyCreatures.push(...cell.creatures);
                });

                let nearestFood = null, nearestDanger = null, nearestPrey = null;
                let nearestFoodDistance = Infinity, nearestDangerDistance = Infinity, nearestPreyDistance = Infinity;
                let numNearbyFood = 0, numNearbyCreatures = 0;

                for (const food of nearbyFood) {
                    const distance = this.calculateWrappedDistance(this.x, this.y, food.x, food.y);
                    if (distance <= this.visionRange) {
                        numNearbyFood++;
                        if (distance < nearestFoodDistance) {
                            nearestFoodDistance = distance;
                            nearestFood = food;
                        }
                    }
                }

                for (const creature of nearbyCreatures) {
                    if (creature !== this) {
                        const distance = this.calculateWrappedDistance(this.x, this.y, creature.x, creature.y);
                        if (distance <= this.visionRange) {
                            numNearbyCreatures++;
                            if (creature.size > this.size && colorDifference(this.color, creature.color) > CONFIG.colorDifferenceThreshold && distance < nearestDangerDistance) {
                                nearestDangerDistance = distance;
                                nearestDanger = creature;
                            } else if (creature.size < this.size && colorDifference(this.color, creature.color) > CONFIG.colorDifferenceThreshold && distance < nearestPreyDistance && creature.parent !== kingCreature) {
                                nearestPreyDistance = distance;
                                nearestPrey = creature;
                            }
                        }
                    }
                }

                this.seekingFood = false;
                let targetDirection = this.direction;

                if (nearestFood) {
                    targetDirection = Math.atan2(nearestFood.y - this.y, nearestFood.x - this.x);
                    this.seekingFood = true;
                } else if (nearestDanger) {
                    targetDirection = (Math.atan2(nearestDanger.y - this.y, nearestDanger.x - this.x) + Math.PI) % (2 * Math.PI);
                } else if (nearestPrey) {
                    targetDirection = Math.atan2(nearestPrey.y - this.y, nearestPrey.x - this.x);
                }

                const turnAmount = Math.PI / 10;
                this.direction = this.direction + Math.sign(targetDirection - this.direction) * turnAmount;
                this.direction = this.direction % (2 * Math.PI);

                const inputs = [
                    nearestFood ? nearestFoodDistance / this.visionRange : 1,
                    nearestDanger ? nearestDangerDistance / this.visionRange : 1,
                    nearestPrey ? nearestPreyDistance / this.visionRange : 1,
                    Math.cos(targetDirection - this.direction),
                    Math.sin(targetDirection - this.direction),
                    this.energy / this.maxEnergy,
                    this.speed / this.maxSpeed,
                    numNearbyFood / CONFIG.maxNearbyFood,
                    numNearbyCreatures / CONFIG.maxNearbyCreatures
                ];

                const outputs = this.brain.feedforward([inputs]);
                this.speed = outputs[0][0] * this.maxSpeed;
                this.acceleration = outputs[0][1] * this.maxAcceleration;
            }

            calculateWrappedDistance(x1, y1, x2, y2) {
                const dx = Math.min(Math.abs(x1 - x2), canvas.width - Math.abs(x1 - x2));
                const dy = Math.min(Math.abs(y1 - y2), canvas.height - Math.abs(y1 - y2));
                return Math.hypot(dx, dy);
            }

            eat() {
                for (let i = 0; i < foodItems.length; i++) {
                    const food = foodItems[i];
                    if (this.calculateWrappedDistance(this.x, this.y, food.x, food.y) < this.size + food.size) {
                        const absorptionAmount = Math.min(CONFIG.absorptionRate, food.energy);
                        this.energy = Math.min(this.energy + absorptionAmount, this.maxEnergy);
                        this.size = Math.sqrt(this.energy) * CONFIG.sizeEnergyMultiplier * parseFloat(creatureSizeSlider.value);
                        food.energy -= absorptionAmount;
                        food.size = Math.sqrt(food.energy) * parseFloat(foodSizeSlider.value);
                        if (food.energy <= CONFIG.minFoodSize) {
                            despawnFood(i);
                        }
                        break;
                    }
                }
            }

            absorb() {
                for (let i = 0; i < creatures.length; i++) {
                    const creature = creatures[i];
                    if (creature !== this && this.calculateWrappedDistance(this.x, this.y, creature.x, creature.y) < this.size + creature.size && creature.size < this.size && colorDifference(this.color, creature.color) > CONFIG.colorDifferenceThreshold && creature.parent !== kingCreature) {
                        const absorptionAmount = Math.min(CONFIG.absorptionRate, creature.energy);
                        this.energy = Math.min(this.energy + absorptionAmount, this.maxEnergy);
                        this.size = Math.sqrt(this.energy) * CONFIG.sizeEnergyMultiplier * parseFloat(creatureSizeSlider.value);
                        creature.energy -= absorptionAmount;
                        creature.size = Math.sqrt(creature.energy) * CONFIG.sizeEnergyMultiplier * parseFloat(creatureSizeSlider.value);

                        if (kingCreature === creature && creature.energy / creature.maxEnergy < 0.25) {
                            kingCreature = this;
                        }

                        if (creature.energy <= CONFIG.minFoodSize) {
                            if (kingCreature === creature) {
                                kingCreature = this;
                            }
                            despawnCreature(i);
                        }

                        if (this.energy === this.maxEnergy) {
                            this.reproduce();
                        }
                        break;
                    }
                }

                if (!kingCreature) {
                    kingCreature = this;
                }
            }

            reproduce() {
                if (this.energy > this.reproductionThreshold) {
                    if (creatures.length >= CONFIG.maxCreatures) {
                        let smallestCreatureIndex = -1;
                        let smallestCreatureSize = Infinity;

                        for (let i = 0; i < creatures.length; i++) {
                            if (creatures[i].size < smallestCreatureSize) {
                                smallestCreatureSize = creatures[i].size;
                                smallestCreatureIndex = i;
                            }
                        }

                        if (smallestCreatureIndex !== -1) {
                            despawnCreature(smallestCreatureIndex);
                        }
                    }

                    const offspringEnergy = this.energy * CONFIG.offspringEnergyFraction;
                    this.energy *= (1 - CONFIG.offspringEnergyFraction);
                    this.size = Math.sqrt(this.energy) * CONFIG.sizeEnergyMultiplier * parseFloat(creatureSizeSlider.value);

                    const offspringTraits = {
                        energy: offspringEnergy,
                        maxSpeed: mutateValue(this.maxSpeed, CONFIG.baseMutationRate / 10),
                        maxAcceleration: mutateValue(this.maxAcceleration, CONFIG.baseMutationRate),
                        visionRange: mutateValue(this.visionRange, CONFIG.baseMutationRate),
                        maxEnergy: mutateValue(this.maxEnergy, CONFIG.baseMutationRate * 2),
                        color: mutateColor(this.color),
                        baseEnergyLossRate: mutateValue(this.baseEnergyLossRate, CONFIG.baseMutationRate / 20),
                        brain: {
                            layerSizes: this.brain.weights.map(w => w.length),
                            weights: this.brain.weights.map(w => w.map(row => row.slice())),
                            biases: this.brain.biases.map(b => b.map(row => row.slice()))
                        }
                    };

                    const offspring = new Creature(this.x, this.y, offspringTraits, this);
                    offspring.brain.mutate(CONFIG.baseMutationRate);
                    creatures.push(offspring);
                    updateCounters();
                }
            }

            shiftColor() {
                const hue = getColorHue(this.color);
                const newHue = (hue + 1) % 360;
                this.color = `hsl(${newHue}, 100%, 50%)`;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                if (this === kingCreature) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 4, 0, 2 * Math.PI);
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 8, 0, 2 * Math.PI);
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                if (this === lastClickedCreature) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = `${this.size * 2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('*', this.x, this.y);
                }
            }

            handleInteractionStart(x, y) {
                const currentTime = new Date().getTime();
                if (currentTime - this.lastClickTime < 300) {
                    this.handleDoubleClick(x, y);
                }
                this.lastClickTime = currentTime;

                if (Math.hypot(x - this.x, y - this.y) < this.size) {
                    this.dragging = true;
                    this.dragStartX = x - this.x;
                    this.dragStartY = y - this.y;
                    lastClickedCreature = this;
                    updateCreatureStats();
                }
            }

            handleInteractionMove(x, y) {
                if (this.dragging) {
                    this.x = x - this.dragStartX;
                    this.y = y - this.dragStartY;
                }
            }

            handleInteractionEnd() {
                this.dragging = false;
            }

            handleDoubleClick(x, y) {
                if (Math.hypot(x - this.x, y - this.y) < this.size) {
                    if (this === kingCreature) {
                        randomizeAllCreatureColors();
                    } else {
                        this.color = randomColor();
                    }
                }
            }

            preventOverlap() {
                for (let other of creatures) {
                    if (other !== this && other.alive) {
                        let distance = this.calculateWrappedDistance(this.x, this.y, other.x, other.y);
                        let minDistance = (this.size + other.size) * 0.75;

                        if (distance < minDistance) {
                            let overlap = minDistance - distance;
                            let angle = Math.atan2(other.y - this.y, other.x - this.x);
                            let smallerCreature = this.size < other.size ? this : other;
                            let pushBack = overlap;

                            smallerCreature.x -= pushBack * Math.cos(angle);
                            smallerCreature.y -= pushBack * Math.sin(angle);

                            smallerCreature.wrapAroundCanvas();
                        }
                    }
                }
            }
        }

        function spawnCreature(x, y, traits = {}, parent = null) {
            if (!parent) {
                traits.maxEnergy = Math.random() * CONFIG.maxEnergy;
                traits.energy = traits.maxEnergy * 0.1;
            }
            const newCreature = new Creature(x, y, traits, parent);
            newCreature.wrapAroundCanvas();
            creatures.push(newCreature);
            updateCounters();
        }

        function spawnFood(x, y, energy = CONFIG.foodEnergy * 0.1) {
            const newFood = new Food(x, y, energy);
            newFood.wrapAroundCanvas();
            foodItems.push(newFood);
            updateCounters();
        }

        function despawnCreature(index) {
            creatures.splice(index, 1);
            updateCounters();
        }

        function despawnFood(index) {
            foodItems.splice(index, 1);
            updateCounters();
        }

        function initialSpawn() {
            for (let i = 0; i < CONFIG.initialCreatures; i++) {
                spawnCreature(Math.random() * canvas.width, Math.random() * canvas.height);
            }
            for (let i = 0; i < CONFIG.initialFoodItems; i++) {
                spawnFood(Math.random() * canvas.width, Math.random() * canvas.height);
            }
            updateCounters();
        }

        initialSpawn();

        let lastFrameTime = performance.now(), frameCount = 0, fps = 0;
        let grid;

        function updateFPS() {
            const now = performance.now();
            if (now - lastFrameTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFrameTime = now;
            }
            frameCount++;
        }

        function enforceMinMaxCounts() {
            if (creatures.length < CONFIG.minCreatures) {
                for (let i = creatures.length; i < CONFIG.minCreatures; i++) {
                    spawnCreature(Math.random() * canvas.width, Math.random() * canvas.height);
                }
            }

            if (foodItems.length < CONFIG.minFoodItems) {
                for (let i = foodItems.length; i < CONFIG.minFoodItems; i++) {
                    spawnFood(Math.random() * canvas.width, Math.random() * canvas.height);
                }
            }
        }

        function adjustFoodGrowthRate() {
            const error = CONFIG.targetCreatureCount - creatures.length;
            CONFIG.foodGrowthRate += error * CONFIG.adjustmentRate;
            CONFIG.foodGrowthRate = Math.max(0.75, CONFIG.foodGrowthRate);
            document.getElementById('foodGrowthRate').value = CONFIG.foodGrowthRate;
            document.getElementById('foodGrowthRateNumber').value = CONFIG.foodGrowthRate;
        }

        function calculateAverageSpeed() {
            const totalSpeed = creatures.reduce((sum, creature) => sum + creature.maxSpeed, 0);
            return totalSpeed / creatures.length;
        }

        function regulateCreatureSpeed() {
            const averageSpeed = calculateAverageSpeed();
            const speedAdjustmentFactor = CONFIG.desiredAverageSpeed / averageSpeed;

            creatures.forEach(creature => {
                creature.maxSpeed *= speedAdjustmentFactor;
            });
        }

        function evolve() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const now = performance.now();
            const deltaTime = (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            const numCols = 20;
            const cellSize = canvas.width / numCols;
            const numRows = Math.ceil(canvas.height / cellSize);
            grid = Array.from({ length: numRows }, () => Array.from({ length: numCols }, () => ({ creatures: [], foodItems: [] })));

            creatures.forEach(creature => {
                const col = Math.floor(creature.x / cellSize);
                const row = Math.floor(creature.y / cellSize);
                grid[row][col].creatures.push(creature);
            });

            foodItems.forEach(food => {
                const col = Math.floor(food.x / cellSize);
                const row = Math.floor(food.y / cellSize);
                grid[row][col].foodItems.push(food);
            });

            if (!isPaused) {
                for (let i = foodItems.length - 1; i >= 0; i--) {
                    const food = foodItems[i];
                    if (food.isOutOfBounds()) {
                        despawnFood(i);
                    } else {
                        food.grow();
                    }
                }

                for (let i = creatures.length - 1; i >= 0; i--) {
                    const creature = creatures[i];
                    if (creature.alive) {
                        creature.move(deltaTime);
                        creature.eat();
                        creature.absorb();
                        creature.reproduce();
                    } else {
                        if (kingCreature === creature) {
                            kingCreature = null;
                        }
                        despawnCreature(i);
                    }
                }

                if (!kingCreature && creatures.length > 0) {
                    kingCreature = creatures[Math.floor(Math.random() * creatures.length)];
                }

                if (kingCreature) {
                    kingCreature.shiftColor();
                }

                if (foodItems.length < CONFIG.maxFoodItems && Date.now() - lastFoodSpawnTime > CONFIG.foodSpawnInterval) {
                    spawnFood(Math.random() * canvas.width, Math.random() * canvas.height);
                    lastFoodSpawnTime = Date.now();
                }

                enforceMinMaxCounts();
                adjustFoodGrowthRate();
                regulateCreatureSpeed();
            }

            foodItems.forEach(food => food.draw());
            creatures.forEach(creature => creature.draw());

            updateFPS();
            updateCreatureStats();
            fadeOverlayText();
            requestAnimationFrame(evolve);
        }

        function fadeOverlayText() {
            const now = Date.now();
            const timeSinceLastClick = now - lastClickTime;

            if (timeSinceLastClick > CONFIG.overlayFadeDelay && optionsMenu.style.display === 'none') {
                creatureCounter.style.opacity = 0;
                foodCounter.style.opacity = 0;
                creatureStats.style.opacity = 0;
            }
        }

        function isBlankSpace(x, y) {
            for (const creature of creatures) {
                if (Math.hypot(x - creature.x, y - creature.y) < creature.size) {
                    return false;
                }
            }
            for (const food of foodItems) {
                if (Math.hypot(x - food.x, y - food.y) < food.size) {
                    return false;
                }
            }
            return true;
        }

        function handleInteraction(event, interactionType) {
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX || (event.touches ? event.touches[0].clientX : 0)) - rect.left;
            const y = (event.clientY || (event.touches ? event.touches[0].clientY : 0)) - rect.top;

            if (interactionType === 'Start' || interactionType === 'End') {
                lastClickTime = Date.now();
                creatureCounter.style.opacity = 1;
                foodCounter.style.opacity = 1;
                creatureStats.style.opacity = 1;
            }

            if (interactionType === 'Start') {
                if (isBlankSpace(x, y) && foodItems.length < CONFIG.maxFoodItems) {
                    currentSpawn = new Food(x, y, CONFIG.foodEnergy * 0.1);
                    currentSpawn.dragging = true;
                    foodItems.push(currentSpawn);
                    updateCounters();
                }
            } else if (interactionType === 'Move' && currentSpawn) {
                currentSpawn.handleInteractionMove(x, y);
            } else if (interactionType === 'End' && currentSpawn) {
                currentSpawn.handleInteractionEnd();
                currentSpawn = null;
            }

            creatures.forEach(creature => creature[`handleInteraction${interactionType}`]?.(x, y));
            foodItems.forEach(food => food[`handleInteraction${interactionType}`]?.(x, y));
        }

        function randomizeAllCreatureColors() {
            creatures.forEach(creature => {
                creature.color = randomColor();
            });
        }

        function saveState(slot) {
            const slotNameInput = document.getElementById(`saveSlotName${slot}`);
            const slotName = slotNameInput.value.trim() || `Save Slot ${slot}`;
            slotNameInput.value = slotName;

            const state = {
                creatures: creatures.map(creature => {
                    const layerSizes = [creature.brain.weights[0].length];
                    creature.brain.weights.forEach(w => layerSizes.push(w[0].length));
                    return {
                        x: creature.x,
                        y: creature.y,
                        maxEnergy: creature.maxEnergy,
                        energy: creature.energy,
                        size: creature.size,
                        color: creature.color,
                        maxSpeed: creature.maxSpeed,
                        maxAcceleration: creature.maxAcceleration,
                        baseEnergyLossRate: creature.baseEnergyLossRate,
                        visionRange: creature.visionRange,
                        isKing: kingCreature === creature,
                        parentIndex: creature.parent ? creatures.indexOf(creature.parent) : -1,
                        brain: {
                            layerSizes: layerSizes,
                            weights: creature.brain.weights.map(w => w.map(row => row.slice())),
                            biases: creature.brain.biases.map(b => b.map(row => row.slice()))
                        }
                    };
                }),
                foodItems: foodItems.map(food => ({
                    x: food.x,
                    y: food.y,
                    energy: food.energy,
                    size: food.size
                })),
                config: { ...CONFIG },
                creatureSize: parseFloat(creatureSizeSlider.value),
                foodSize: parseFloat(foodSizeSlider.value),
                saveSlotName: slotName
            };
            localStorage.setItem(`saveSlot${slot}`, JSON.stringify(state));
        }

        function loadState(slot) {
            try {
                const state = JSON.parse(localStorage.getItem(`saveSlot${slot}`));
                if (state) {
                    creatures.length = 0;
                    foodItems.length = 0;
                    kingCreature = null;

                    state.creatures.forEach(creatureData => {
                        const creature = new Creature(
                            creatureData.x, 
                            creatureData.y, 
                            {
                                maxEnergy: creatureData.maxEnergy,
                                energy: creatureData.energy,
                                size: creatureData.size,
                                color: creatureData.color,
                                maxSpeed: creatureData.maxSpeed,
                                maxAcceleration: creatureData.maxAcceleration,
                                baseEnergyLossRate: creatureData.baseEnergyLossRate || creatureData.energyLossRate,
                                visionRange: creatureData.visionRange,
                                brain: {
                                    layerSizes: creatureData.brain.layerSizes,
                                    weights: creatureData.brain.weights,
                                    biases: creatureData.brain.biases
                                }
                            }
                        );
                        if (creatureData.isKing) {
                            kingCreature = creature;
                        }
                        creatures.push(creature);
                    });

                    state.creatures.forEach((creatureData, index) => {
                        if (creatureData.parentIndex !== -1) {
                            creatures[index].parent = creatures[creatureData.parentIndex];
                        } else {
                            creatures[index].parent = null;
                        }
                    });

                    state.foodItems.forEach(foodData => {
                        const food = new Food(
                            foodData.x, 
                            foodData.y, 
                            foodData.energy
                        );
                        food.size = foodData.size;
                        foodItems.push(food);
                    });

                    CONFIG = { ...state.config };

                    options.forEach(option => {
                        const slider = document.getElementById(option.slider);
                        const number = document.getElementById(option.number);
                        slider.value = CONFIG[option.slider];
                        number.value = CONFIG[option.slider];
                    });

                    if (state.creatureSize) {
                        creatureSizeSlider.value = state.creatureSize;
                        creatureSizeNumber.value = state.creatureSize;
                        creatures.forEach(creature => {
                            creature.size = Math.sqrt(creature.energy) * CONFIG.sizeEnergyMultiplier * state.creatureSize;
                        });
                    }
                    if (state.foodSize) {
                        foodSizeSlider.value = state.foodSize;
                        foodSizeNumber.value = state.foodSize;
                        foodItems.forEach(food => {
                            food.size = Math.sqrt(food.energy) * state.foodSize;
                        });
                    }

                    updateCounters();
                }
            } catch (error) {
                console.error('Failed to load state:', error);
            }
        }

        function resetSettings() {
            CONFIG = { ...defaultConfig };
            options.forEach(option => {
                const slider = document.getElementById(option.slider);
                const number = document.getElementById(option.number);
                slider.value = defaultConfig[option.slider];
                number.value = defaultConfig[option.slider];
            });
            creatureSizeSlider.value = defaultCreatureSize;
            creatureSizeNumber.value = defaultCreatureSize;
            foodSizeSlider.value = defaultFoodSize;
            foodSizeNumber.value = defaultFoodSize;
            creatures.forEach(creature => {
                creature.size = Math.sqrt(creature.energy) * CONFIG.sizeEnergyMultiplier * defaultCreatureSize;
            });
            foodItems.forEach(food => {
                food.size = Math.sqrt(food.energy) * defaultFoodSize;
            });
        }

        function resetPopulation() {
            creatures.length = 0;
            foodItems.length = 0;
            initialSpawn();
            updateCounters();
        }

        function resetSimulation() {
            resetSettings();
            resetPopulation();
        }

        function deleteAllSaves() {
            for (let i = 1; i <= 10; i++) {
                localStorage.removeItem(`saveSlot${i}`);
                const slotNameInput = document.getElementById(`saveSlotName${i}`);
                slotNameInput.value = `Save Slot ${i}`;
            }
        }

        canvas.addEventListener('mousedown', e => handleInteraction(e, 'Start'));
        canvas.addEventListener('mousemove', e => handleInteraction(e, 'Move'));
        canvas.addEventListener('mouseup', e => handleInteraction(e, 'End'));
        canvas.addEventListener('touchstart', e => handleInteraction(e, 'Start'));
        canvas.addEventListener('touchmove', e => handleInteraction(e, 'Move'));
        canvas.addEventListener('touchend', e => handleInteraction(e, 'End'));

        creatureSizeSlider.addEventListener('input', () => {
            const value = parseFloat(creatureSizeSlider.value);
            creatureSizeNumber.value = value;
            creatures.forEach(creature => {
                creature.size = Math.sqrt(creature.energy) * CONFIG.sizeEnergyMultiplier * value;
            });
        });
        creatureSizeNumber.addEventListener('input', () => {
            const value = parseFloat(creatureSizeNumber.value);
            creatureSizeSlider.value = value;
            creatures.forEach(creature => {
                creature.size = Math.sqrt(creature.energy) * CONFIG.sizeEnergyMultiplier * value;
            });
        });

        foodSizeSlider.addEventListener('input', () => {
            const value = parseFloat(foodSizeSlider.value);
            foodSizeNumber.value = value;
            foodItems.forEach(food => {
                food.size = Math.sqrt(food.energy) * value;
            });
        });
        foodSizeNumber.addEventListener('input', () => {
            const value = parseFloat(foodSizeNumber.value);
            foodSizeSlider.value = value;
            foodItems.forEach(food => {
                food.size = Math.sqrt(food.energy) * value;
            });
        });

        gearIcon.addEventListener('click', () => {
            const isMenuVisible = optionsMenu.style.display !== 'none';
            optionsMenu.style.display = isMenuVisible ? 'none' : 'flex';
            creatureCounter.style.opacity = isMenuVisible ? 0 : 1;
            foodCounter.style.opacity = isMenuVisible ? 0 : 1;
            creatureStats.style.opacity = isMenuVisible ? 0 : 1;
        });

        pauseButton.addEventListener('click', () => {
            isPaused = !isPaused;
            pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
        });

        window.addEventListener('click', (event) => {
            if (!optionsMenu.contains(event.target) && event.target !== gearIcon) {
                optionsMenu.style.display = 'none';
                creatureCounter.style.opacity = 0;
                foodCounter.style.opacity = 0;
                creatureStats.style.opacity = 0;
            }
        });

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                    if (content.id === tabId) content.classList.add('active');
                });
            });
        });

        options.forEach(option => {
            const slider = document.getElementById(option.slider);
            const number = document.getElementById(option.number);

            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                number.value = value;
                CONFIG[option.slider] = value;
            });

            number.addEventListener('input', () => {
                let value = parseFloat(number.value);
                if (isNaN(value) || value < parseFloat(number.min) || value > parseFloat(number.max)) {
                    value = parseFloat(slider.value);
                    number.value = value;
                }
                slider.value = value;
                CONFIG[option.slider] = value;
            });
        });

        document.addEventListener('DOMContentLoaded', () => {
            for (let i = 1; i <= 10; i++) {
                const slotNameInput = document.getElementById(`saveSlotName${i}`);
                const state = JSON.parse(localStorage.getItem(`saveSlot${i}`));
                if (state) {
                    slotNameInput.value = state.saveSlotName || `Save Slot ${i}`;
                }
            }
        });

        evolve();
    </script>
</body>
</html>
